import os
import re
from dataclasses import dataclass
from typing import Optional, Tuple

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from scipy.signal import savgol_filter
from statsmodels.nonparametric.smoothers_lowess import lowess


# ----------------------------
# Config
# This files are generated by Wireshark. Adjust paths as needed.
# ----------------------------

CSV_FILES = {
    "MOVE_LOS": "MOVE_4M_LOS.csv",
    "STATIC_2M_LOS": "STATIC_2M_LOS.csv",
    "STATIC_4M_LOS": "STATIC_4M_LOS.csv",
    "MOVE_NLOS": "MOVE_4M_NLOS.csv",
    "STATIC_2M_NLOS": "STATIC_2M_NLOS.csv",
    "STATIC_4M_NLOS": "STATIC_4M_NLOS.csv",
}

RSSI_COL = "Signal strength (dBm)"
TIME_COL = "Time"

OUT_DIR = "plots/"

# Movement distances (for continuous measurements)
# In this example, we move the computer from 4m to 0.2m distance to the AP.
MOVE_START_M = 4.0
MOVE_END_M = 0.2

# Filters
MOVING_AVG_WINDOW = 25
SAVGOL_WINDOW = 51
SAVGOL_POLYORDER = 2
LOWESS_FRAC = 0.08

# ----------------------------
# Helpers
# ----------------------------

def _safe_float_series(s: pd.Series) -> pd.Series:
    """Convert weird Time formats safely: keep numeric; extract leading float if needed."""
    if pd.api.types.is_numeric_dtype(s):
        return s.astype(float)

    extracted = s.astype(str).str.extract(r"([-+]?\d*\.?\d+)")[0]
    return pd.to_numeric(extracted, errors="coerce")


def load_and_clean(path: str) -> pd.DataFrame:
    if not os.path.exists(path):
        raise FileNotFoundError(f"Missing file: {path}")

    df = pd.read_csv(path, sep=None, engine="python")

    if TIME_COL not in df.columns or RSSI_COL not in df.columns:
        raise ValueError(
            f"{path}: Expected columns '{TIME_COL}' and '{RSSI_COL}'. "
            f"Found columns: {list(df.columns)}"
        )

    df[TIME_COL] = _safe_float_series(df[TIME_COL])

    rssi_raw = df[RSSI_COL].astype(str).str.replace(",", ".", regex=False)
    rssi_extracted = rssi_raw.str.extract(r"([-+]?\d+(?:\.\d+)?)")[0]
    df[RSSI_COL] = pd.to_numeric(rssi_extracted, errors="coerce")

    # Drop invalid rows
    df = df.dropna(subset=[TIME_COL, RSSI_COL]).copy()

    # Remove RSSI == 0 (happend in my wireshark captures; likely invalid for my device?)
    before = len(df)
    df = df[df[RSSI_COL] != 0].copy()
    after = len(df)

    # Sort by time
    df = df.sort_values(TIME_COL).reset_index(drop=True)

    print(f"[load] {os.path.basename(path)}: rows {before} -> {after} after removing RSSI==0")

    return df


def moving_average(y: np.ndarray, window: int) -> Tuple[np.ndarray, np.ndarray]:
    """Return (x_index, y_ma) aligned to original index via 'valid' convolution."""
    if window <= 1 or window > len(y):
        return np.arange(len(y)), y
    kernel = np.ones(window) / window
    y_ma = np.convolve(y, kernel, mode="valid")
    x_ma = np.arange(len(y_ma)) + (window - 1) / 2
    return x_ma, y_ma


def savgol(y: np.ndarray, window: int, poly: int) -> np.ndarray:
    if len(y) < 5:
        return y
    w = min(window, len(y))
    if w % 2 == 0:
        w -= 1
    if w < poly + 2:
        return y
    return savgol_filter(y, window_length=w, polyorder=min(poly, w - 2))


def lowess_smooth(x: np.ndarray, y: np.ndarray, frac: float) -> np.ndarray:
    if len(y) < 10:
        return y
    frac = max(0.01, min(frac, 1.0))
    out = lowess(y, x, frac=frac, return_sorted=True)

    xs, ys = out[:, 0], out[:, 1]
    return np.interp(x, xs, ys)


def time_to_distance(time: np.ndarray, d_start: float, d_end: float) -> np.ndarray:
    """Linear mapping time -> distance for continuous measurement."""
    t0 = time[0]
    t1 = time[-1]
    if t1 == t0:
        return np.full_like(time, d_end)
    return d_start + (time - t0) * (d_end - d_start) / (t1 - t0)


@dataclass
class StaticStats:
    distance_m: float
    mean_dbm: float
    std_dbm: float
    n: int


def compute_static_stats(df: pd.DataFrame, distance_m: float) -> StaticStats:
    y = df[RSSI_COL].to_numpy()
    return StaticStats(
        distance_m=distance_m,
        mean_dbm=float(np.mean(y)),
        std_dbm=float(np.std(y, ddof=1)) if len(y) > 1 else 0.0,
        n=len(y),
    )


# ----------------------------
# Plotting
# ----------------------------

def plot_continuous(df: pd.DataFrame, title: str, out_path: str,
                    d_start: float, d_end: float) -> None:
    if df.empty:
        raise ValueError(
            f"{title}: no data after cleaning. "
            f"Check that '{RSSI_COL}' contains non-zero numeric values."
        )

    time = df[TIME_COL].to_numpy()
    rssi = df[RSSI_COL].to_numpy()

    # Extra safety
    if len(time) < 5:
        raise ValueError(f"{title}: not enough samples ({len(time)}). Capture longer or reduce filtering windows.")

    dist = time_to_distance(time, d_start, d_end)

    x_ma_idx, rssi_ma = moving_average(rssi, MOVING_AVG_WINDOW)
    dist_ma = np.interp(x_ma_idx, np.arange(len(dist)), dist)

    rssi_sg = savgol(rssi, SAVGOL_WINDOW, SAVGOL_POLYORDER)
    rssi_lo = lowess_smooth(dist, rssi, LOWESS_FRAC)

    plt.figure()
    plt.scatter(dist, rssi, s=6, alpha=0.25, label="Raw")
    plt.plot(dist_ma, rssi_ma, label=f"Moving average (w={MOVING_AVG_WINDOW})")
    plt.plot(dist, rssi_sg, label=f"Savitzky-Golay (p={SAVGOL_POLYORDER})")
    plt.plot(dist, rssi_lo, label=f"LOWESS (frac={LOWESS_FRAC})")
    plt.xlabel("Estimated distance (m)")
    plt.ylabel("Signal strength (dBm)")
    plt.title(title)
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_path, dpi=200)
    plt.close()


def plot_static(stats_list: list[StaticStats], title: str, out_path: str) -> None:
    stats_list = sorted(stats_list, key=lambda s: s.distance_m)
    x = np.array([s.distance_m for s in stats_list])
    y = np.array([s.mean_dbm for s in stats_list])
    yerr = np.array([s.std_dbm for s in stats_list])

    plt.figure()
    plt.errorbar(x, y, yerr=yerr, fmt="o", capsize=4)
    plt.xlabel("Distance (m)")
    plt.ylabel("Signal strength (dBm)")
    plt.title(title)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(out_path, dpi=200)
    plt.close()


def plot_compare_continuous(df_los: pd.DataFrame, df_nlos: pd.DataFrame,
                            title: str, out_path: str,
                            d_start: float, d_end: float) -> None:

    def prep(df: pd.DataFrame):
        time = df[TIME_COL].to_numpy()
        rssi = df[RSSI_COL].to_numpy()
        dist = time_to_distance(time, d_start, d_end)
        rssi_sg = savgol(rssi, SAVGOL_WINDOW, SAVGOL_POLYORDER)
        return dist, rssi_sg

    dist_los, y_los = prep(df_los)
    dist_nlos, y_nlos = prep(df_nlos)

    plt.figure()
    plt.plot(dist_los, y_los, label="LOS (Savitzky-Golay)")
    plt.plot(dist_nlos, y_nlos, label="NLOS (Savitzky-Golay)")
    plt.xlabel("Estimated distance (m)")
    plt.ylabel("Signal strength (dBm)")
    plt.title(title)
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.savefig(out_path, dpi=200)
    plt.close()


# ----------------------------
# Main
# ----------------------------

def main():
    os.makedirs(OUT_DIR, exist_ok=True)

    # Load all
    data = {k: load_and_clean(v) for k, v in CSV_FILES.items()}

    # --- Continuous (movement) plots ---
    plot_continuous(
        data["MOVE_LOS"],
        title="Continuous measurement (LOS) - RSSI vs estimated distance",
        out_path=os.path.join(OUT_DIR, "continuous_LOS.png"),
        d_start=MOVE_START_M,
        d_end=MOVE_END_M,
    )

    plot_continuous(
        data["MOVE_NLOS"],
        title="Continuous measurement (NLOS) - RSSI vs estimated distance",
        out_path=os.path.join(OUT_DIR, "continuous_NLOS.png"),
        d_start=MOVE_START_M,
        d_end=MOVE_END_M,
    )

    # --- Static stats/plots ---
    static_los = [
        compute_static_stats(data["STATIC_2M_LOS"], 2.0),
        compute_static_stats(data["STATIC_4M_LOS"], 4.0),
    ]
    plot_static(
        static_los,
        title="Static measurement (LOS) - mean RSSI ± std",
        out_path=os.path.join(OUT_DIR, "static_LOS.png"),
    )

    static_nlos = [
        compute_static_stats(data["STATIC_2M_NLOS"], 2.0),
        compute_static_stats(data["STATIC_4M_NLOS"], 4.0),
    ]
    plot_static(
        static_nlos,
        title="Static measurement (NLOS) - mean RSSI ± std",
        out_path=os.path.join(OUT_DIR, "static_NLOS.png"),
    )

    # --- LOS vs NLOS comparison for continuous measurements ---
    plot_compare_continuous(
        data["MOVE_LOS"],
        data["MOVE_NLOS"],
        title="Continuous measurement comparison: LOS vs NLOS",
        out_path=os.path.join(OUT_DIR, "continuous_compare_LOS_vs_NLOS.png"),
        d_start=MOVE_START_M,
        d_end=MOVE_END_M,
    )

    print("Done. Plots saved in:", OUT_DIR)

if __name__ == "__main__":
    main()
